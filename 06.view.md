# An Http Request Through Rails

### 06. View

从这章开始解析ActionView的代码，Rails处理View的逻辑相当复杂，需要非常小心的将其一一分解。这里先从第一步，Mime开始。

Rails关于Mime的功能分在多个文件中，以`Mime`模块为基本模块，定义在`actionpack-3.2.13/lib/action_dispatch/http/mime_type.rb`中。`Mime::Type`是核心的数据类型，然后是`Mime::Mimes`是`Array`的子类，其实例对象`Mime::SET`存储了所有在Rails中注册过的Mime类型。Rails所有用到的Mime类型都必须经过注册，其中默认的注册代码全部写在`actionpack-3.2.13/lib/action_dispatch/http/mime_types.rb`：

```ruby
# Build list of Mime types for HTTP responses
# http://www.iana.org/assignments/media-types/

Mime::Type.register "text/html", :html, %w( application/xhtml+xml ), %w( xhtml )
Mime::Type.register "text/plain", :text, [], %w(txt)
Mime::Type.register "text/javascript", :js, %w( application/javascript application/x-javascript )
Mime::Type.register "text/css", :css
Mime::Type.register "text/calendar", :ics
Mime::Type.register "text/csv", :csv

Mime::Type.register "image/png", :png, [], %w(png)
Mime::Type.register "image/jpeg", :jpeg, [], %w(jpg jpeg jpe)
Mime::Type.register "image/gif", :gif, [], %w(gif)
Mime::Type.register "image/bmp", :bmp, [], %w(bmp)
Mime::Type.register "image/tiff", :tiff, [], %w(tif tiff)

Mime::Type.register "video/mpeg", :mpeg, [], %w(mpg mpeg mpe)

Mime::Type.register "application/xml", :xml, %w( text/xml application/x-xml )
Mime::Type.register "application/rss+xml", :rss
Mime::Type.register "application/atom+xml", :atom
Mime::Type.register "application/x-yaml", :yaml, %w( text/yaml )

Mime::Type.register "multipart/form-data", :multipart_form
Mime::Type.register "application/x-www-form-urlencoded", :url_encoded_form

# http://www.ietf.org/rfc/rfc4627.txt
# http://www.json.org/JSONRequest.html
Mime::Type.register "application/json", :json, %w( text/x-json application/jsonrequest )

Mime::Type.register "application/pdf", :pdf, [], %w(pdf)
Mime::Type.register "application/zip", :zip, [], %w(zip)

# Create Mime::ALL but do not add it to the SET.
Mime::ALL = Mime::Type.new("*/*", :all, [])
```
从代码中可见，这里大量调用了`Mime::Type.register`方法，其实现如下：

```ruby
def register(string, symbol, mime_type_synonyms = [], extension_synonyms = [], skip_lookup = false)
  Mime.const_set(symbol.to_s.upcase, Type.new(string, symbol, mime_type_synonyms))

  SET << Mime.const_get(symbol.to_s.upcase)

  ([string] + mime_type_synonyms).each { |str| LOOKUP[str] = SET.last } unless skip_lookup
  ([symbol] + extension_synonyms).each { |ext| EXTENSION_LOOKUP[ext.to_s] = SET.last }
end
```
可以看到`register`的实现实际就是创建一个`Mime::Type`对象并赋值给`Mime`模块下的一个同名常量，然后把常量放入到`SET`对象中，然后将其中的Mime subtype部分放入到`LOOKUP`哈希中，将扩展名 - `Mime::Type`对象放入到`EXTENSION_LOOKUP`哈希中。随后，`Mime`提供了查询功能：

```ruby
def lookup(string)
  LOOKUP[string]
end

def lookup_by_extension(extension)
  EXTENSION_LOOKUP[extension.to_s]
end
```
以上是`Mime`的基本部分，随后让我们开始真正的代码解析：

首先从scaffold默认生成的代码：

```ruby
respond_to do |format|
  format.html # index.html.erb
  format.json { render json: @users }
end
```
开始。

首先，`respond_to`定义在`ActionController::MimeResponds`模块中，定义在`actionpack-3.2.13/lib/action_controller/metal/mime_responds.rb`，从名字即可看出，与Mime有关，实际当然也确实如此。在这个模块中，`respond_to`包含两个版本，类方法和实例方法。

其中类方法的示例如下：

```ruby
class PeopleController < ApplicationController
  respond_to :html, :xml, :json

  def index
    @people = Person.all
    respond_with(@people)
  end
end
```
而实例方法的示例在一开始已经出现。这里我们只解析实例方法的实现，类方法实际上只是Controller级别的设置而已。`respond_to`实例方法的源码如下：

```ruby
def respond_to(*mimes, &block)
  raise ArgumentError, "respond_to takes either types or a block, never both" if mimes.any? && block_given?

  if collector = retrieve_collector_from_mimes(mimes, &block)
    response = collector.response
    response ? response.call : default_render({})
  end
end
```
首先一开始是参数检查，这里通常只有block而没有参数。然后进入了`retrieve_collector_from_mimes`方法：

```ruby
# Collects mimes and return the response for the negotiated format. Returns
# nil if :not_acceptable was sent to the client.
#
def retrieve_collector_from_mimes(mimes=nil, &block) #:nodoc:
  mimes ||= collect_mimes_from_class_level
  collector = Collector.new(mimes)
  block.call(collector) if block_given?
  format = collector.negotiate_format(request)

  if format
    self.content_type ||= format.to_s
    lookup_context.formats = [format.to_sym]
    lookup_context.rendered_format = lookup_context.formats.first
    collector
  else
    head :not_acceptable
    nil
  end
end
```
首先，如果没有设置Mime的话，将试图从类级别的Mime中去取，方法就是`collect_mimes_from_class_level`，虽然这里我们也没有Mime，但是`respond_to`会在这里传入空数组，所以并没有去检查类级别的Mime。如果要检查的话，代码如下：

```ruby
# Collect mimes declared in the class method respond_to valid for the
# current action.
#
def collect_mimes_from_class_level #:nodoc:
  action = action_name.to_s

  self.class.mimes_for_respond_to.keys.select do |mime|
    config = self.class.mimes_for_respond_to[mime]

    if config[:except]
      !action.in?(config[:except])
    elsif config[:only]
      action.in?(config[:only])
    else
      true
    end
  end
end
```
可见也只是将类级别的配置取下后再用`:except`和`:only`过滤下而已。

随后，将会根据Mime创建`ActionController::MimeResponds::Collector`的实例对象。`Collector`类的任务是收集并管理Rails所有的Mime类型。先来看看它的核心模块`AbstractController::Collector`的实现方法：

```ruby
require "action_dispatch/http/mime_type"

module AbstractController
  module Collector
    def self.generate_method_for_mime(mime)
      sym = mime.is_a?(Symbol) ? mime : mime.to_sym
      const = sym.to_s.upcase
      class_eval <<-RUBY, __FILE__, __LINE__ + 1
        def #{sym}(*args, &block)                # def html(*args, &block)
          custom(Mime::#{const}, *args, &block)  #   custom(Mime::HTML, *args, &block)
        end                                      # end
      RUBY
    end

    Mime::SET.each do |mime|
      generate_method_for_mime(mime)
    end

  protected

    def method_missing(symbol, &block)
      mime_constant = Mime.const_get(symbol.to_s.upcase)

      if Mime::SET.include?(mime_constant)
        AbstractController::Collector.generate_method_for_mime(mime_constant)
        send(symbol, &block)
      else
        super
      end
    end
  end
end
```
这个module实际相当于一个抽象类，它提供了对Mime::SET，也就是Rails所有注册的Mime类型的同名方法集合，每个同名方法都是对`custom`方法的调用，而`custom`方法则在实际的类中实现，也就是这里`ActionController::MimeResponds::Collector`的实现：

```ruby
class Collector #:nodoc:
  include AbstractController::Collector
  attr_accessor :order, :format

  def initialize(mimes)
    @order, @responses = [], {}
    mimes.each { |mime| send(mime) }
  end

  def any(*args, &block)
    if args.any?
      args.each { |type| send(type, &block) }
    else
      custom(Mime::ALL, &block)
    end
  end
  alias :all :any

  def custom(mime_type, &block)
    mime_type = Mime::Type.lookup(mime_type.to_s) unless mime_type.is_a?(Mime::Type)
    @order << mime_type
    @responses[mime_type] ||= block
  end

  def response
    @responses[format] || @responses[Mime::ALL]
  end

  def negotiate_format(request)
    @format = request.negotiate_mime(order)
  end
end
```
`custom`方法将Mime类型放入了`@order`数组，然后创建了一个Hash `@response`来实现Mime类型到block的map。这个类的初始化代码对所有传入的Mime类型均调用了同名方法以实现前面叙述的功能。

不过这里我们依然会传入空数组。随后，将新创建的collector对象传入到block中去。也就是我们在Scaffold代码中看到的`format`对象。随后，Scaffold代码中通常定义了html和json两种Mime类型，按照之前解析的代码完成了声明之后，将调用collector的`negotiate_format`方法，这个方法相当于一个代理方法：

```ruby
def negotiate_format(request)
  @format = request.negotiate_mime(order)
end
```
随后将进入request对象的`negotiate_mime`方法，这个方法定义在`ActionDispatch::Http::MimeNegotiation`模块中，`actionpack-3.2.13/lib/action_dispatch/http/mime_negotiation.rb`文件内。该模块的主要任务是，根据发送过来的请求的元信息，与传入的声明的Mime类型，最终可以得到一个匹配的Mime类型出来。`negotiate_mime`方法的实现是：

```ruby
# Receives an array of mimes and return the first user sent mime that
# matches the order array.
#
def negotiate_mime(order)
  formats.each do |priority|
    if priority == Mime::ALL
      return order.first
    elsif order.include?(priority)
      return priority
    end
  end

  order.include?(Mime::ALL) ? formats.first : nil
end
```
`formats`方法确定了所有可以相匹配的Mime类型：

```ruby
def formats
  @env["action_dispatch.request.formats"] ||=
    if parameters[:format]
      Array(Mime[parameters[:format]])
    elsif use_accept_header && valid_accept_header
      accepts
    elsif xhr?
      [Mime::JS]
    else
      [Mime::HTML]
    end
end
```
当请求的URL中有format参数时，将通过`Type.lookup_by_extension`方法根据扩展名查询对应的Mime。否则，如果没有关闭接受ACCEPT Header这个功能的话（`use_accept_header`的返回值要为true）并且用户请求的Mime类型符合要求（`valid_accept_header`的返回值要为true），将按照用户请求的Mime类型来处理，处理方法是`accepts`：

```ruby
# Returns the accepted MIME type for the request.
def accepts
  @env["action_dispatch.request.accepts"] ||= begin
    header = @env['HTTP_ACCEPT'].to_s.strip

    if header.empty?
      [content_mime_type]
    else
      Mime::Type.parse(header)
    end
  end
end
```
主要是调用`Mime::Type.parse`方法来处理：

```ruby
def parse(accept_header)
  if accept_header !~ /,/
    accept_header = accept_header.split(Q_SEPARATOR_REGEXP).first
    if accept_header =~ TRAILING_STAR_REGEXP
      parse_data_with_trailing_star($1)
    else
      [Mime::Type.lookup(accept_header)]
    end
  else
    # keep track of creation order to keep the subsequent sort stable
    list, index = [], 0
    accept_header.split(/,/).each do |header|
      params, q = header.split(Q_SEPARATOR_REGEXP)
      if params.present?
        params.strip!

        if params =~ TRAILING_STAR_REGEXP
          parse_data_with_trailing_star($1).each do |m|
            list << AcceptItem.new(index, m.to_s, q)
            index += 1
          end
        else
          list << AcceptItem.new(index, params, q)
          index += 1
        end
      end
    end
    list.sort!

    # Take care of the broken text/xml entry by renaming or deleting it
    text_xml = list.index("text/xml")
    app_xml = list.index(Mime::XML.to_s)

    if text_xml && app_xml
      # set the q value to the max of the two
      list[app_xml].q = [list[text_xml].q, list[app_xml].q].max

      # make sure app_xml is ahead of text_xml in the list
      if app_xml > text_xml
        list[app_xml], list[text_xml] = list[text_xml], list[app_xml]
        app_xml, text_xml = text_xml, app_xml
      end

      # delete text_xml from the list
      list.delete_at(text_xml)

    elsif text_xml
      list[text_xml].name = Mime::XML.to_s
    end

    # Look for more specific XML-based types and sort them ahead of app/xml

    if app_xml
      idx = app_xml
      app_xml_type = list[app_xml]

      while(idx < list.length)
        type = list[idx]
        break if type.q < app_xml_type.q
        if type.name =~ /\+xml$/
          list[app_xml], list[idx] = list[idx], list[app_xml]
          app_xml = idx
        end
        idx += 1
      end
    end

    list.map! { |i| Mime::Type.lookup(i.name) }.uniq!
    list
  end
end
```
除了`*`号需要特殊处理外，大部分情况下还是简单的用`Mime::Type.lookup`查询即可。

在`formats`完成查询之后，最终获得了所有可以接受的Mime列表。如果其中有`Mime::ALL`的话，那么取写在`respond_to`里的第一个类型，否则仅仅取出声明过的类型。

如果`formats`没有返回值的话，直接设置Header为`not_acceptable`即可。如果有的话，将返回值设置到`lookup_context`的`formats`和`rendered_format`上。

这里我们接触到了`lookup_context`，这个方法定义在`actionpack-3.2.13/lib/abstract_controller/view_paths.rb`的`AbstractController::ViewPaths`模块中：

```ruby
# LookupContext is the object responsible to hold all information required to lookup
# templates, i.e. view paths and details. Check ActionView::LookupContext for more
# information.
def lookup_context
  @_lookup_context ||=
    ActionView::LookupContext.new(self.class._view_paths, details_for_lookup, _prefixes)
end
```
这里`self.class._view_paths`默认是Rails根目录下的`app/views`目录。`details_for_lookup`这里返回空Hash，`_prefixes`则是查询所有View Template可能的前缀：

```ruby
# The prefixes used in render "foo" shortcuts.
def _prefixes
  @_prefixes ||= begin
    parent_prefixes = self.class.parent_prefixes
    parent_prefixes.dup.unshift(controller_path)
  end
end
```
先获取到类方法的`parent_prefixes`，然后将当前`controller_path`放入后返回。`parent_prefixes`的实现如下：

```ruby
def parent_prefixes
  @parent_prefixes ||= begin
    parent_controller = superclass
    prefixes = []

    until parent_controller.abstract?
      prefixes << parent_controller.controller_path
      parent_controller = parent_controller.superclass
    end

    prefixes
  end
end
```
这里的实现就是不断获取父类的`controller_path`直到父类的controller为`abstract?`为止。 因此`_prefixes`实际上返回当前Controller到祖先的所有路径。

至于`LookupContext`的功能，就是封装了需要查找的Template的多个参数，以及存储了所有可用的Template的路径，并且提供了根据路径对Template进行查找的功能，具体实现会在下面解析。

随后回到`respond_to`的代码，如果之前能找到`collector`，那么接下来调用`collector.response`，实现如下：

```ruby
def response
  @responses[format] || @responses[Mime::ALL]
end
```
之前说过，`@responses`记录了Mime类型到用于response的block的Hash，这里将返回这个block。在生成Scaffold代码的时候，html通常没有block，而json一般会有一句`render`语句。如果没有block的话，将会执行`default_render`方法，我们这里解析这个方法，这个方法的实现是这样的：

```ruby
def default_render(*args)
  render(*args)
end
```
可见事实上还是一个`render`方法的调用。而`default_render`的调用形式是这样的：

```ruby
response ? response.call : default_render({})
```
这里传入的是空的hash，相当于全部使用了默认值。

`render`方法分几层实现，这里的第一层是`ActionController::Rendering`的实现，定义在`actionpack-3.2.13/lib/action_controller/metal/rendering.rb`中：

```ruby
# Check for double render errors and set the content_type after rendering.
def render(*args) #:nodoc:
  raise ::AbstractController::DoubleRenderError if response_body
  super
  self.content_type ||= Mime[lookup_context.rendered_format].to_s
  response_body
end
```
仅仅只是检查`response_body`防止render两次，以及针对`content_type`的赋值，最后返回`response_body`的返回值。

随后是`AbstractController::Rendering`模块，定义在`actionpack-3.2.13/lib/abstract_controller/rendering.rb`中：

```ruby
# Normalize arguments, options and then delegates render_to_body and
# sticks the result in self.response_body.
def render(*args, &block)
  options = _normalize_render(*args, &block)
  self.response_body = render_to_body(options)
end
```
这里分两步，`_normalize_render`主要负责生成渲染用的options，而`render_to_body`负责实际的渲染工作。下面是`_normalize_render`的实现：

```ruby
# Normalize args and options.
# :api: private
def _normalize_render(*args, &block)
  options = _normalize_args(*args, &block)
  _normalize_options(options)
  options
end
```
这里同样分两步，`_normalize_args`负责初始化选项，它的实现也有多个层次，`ActionController::Rendering`中的实现是：

```ruby
# Normalize arguments by catching blocks and setting them on :update.
def _normalize_args(action=nil, options={}, &blk) #:nodoc:
  options = super
  options[:update] = blk if block_given?
  options
end
```
仅仅是将block赋值给了`:update`选项，`AbstractController::Rendering`的实现是：

```ruby
# Normalize args by converting render "foo" to render :action => "foo" and
# render "foo/bar" to render :file => "foo/bar".
# :api: plugin
def _normalize_args(action=nil, options={})
  case action
  when NilClass
  when Hash
    options = action
  when String, Symbol
    action = action.to_s
    key = action.include?(?/) ? :file : :action
    options[key] = action
  else
    options[:partial] = action
  end

  options
end
```
这里通过`_normalize_args`初始化了选项。从代码中可见，action如果是Hash的话（在目前的实例中action确实是一个空Hash），则直接赋值给选项（这里就可以简单的视为没有传入action参数，只给了options部分）。如果是字符串或是Symbol，则在options中加入`:file`或是`:action`选项。否则，将其赋值给`:partial`选项。

然后是`_normalize_options`的实现，同样有几层，定义在`actionpack-3.2.13/lib/action_controller/metal/compatibility.rb`的`ActionController::Compatibility`模块中的实现如下：

```ruby
def _normalize_options(options)
  options[:text] = nil if options.delete(:nothing) == true
  options[:text] = " " if options.key?(:text) && options[:text].nil?
  super
end
```
这个方法主要设置`:text`的选项，保证这个参数如果有的话就必须是有至少一个空格的字符串。

`ActionController::Rendering`中的实现部分如下：

```ruby
# Normalize both text and status options.
def _normalize_options(options) #:nodoc:
  if options.key?(:text) && options[:text].respond_to?(:to_text)
    options[:text] = options[:text].to_text
  end

  if options[:status]
    options[:status] = Rack::Utils.status_code(options[:status])
  end

  super
end
```
这里主要是针对`options[:text]`调用`to_text`方法，以及调用`Rack::Utils.status_code`方法处理`:status`，这个方法当传入Symbol的时候会根据`SYMBOL_TO_STATUS_CODE`这个Hash将Status表示的语义转换成对应的状态码。

然后是`AbstractController::Layouts`的实现，代码在`actionpack-3.2.13/lib/abstract_controller/layouts.rb`：

```ruby
def _normalize_options(options)
  super

  if _include_layout?(options)
    layout = options.key?(:layout) ? options.delete(:layout) : :default
    options[:layout] = _layout_for_option(layout)
  end
end
```
首先判定是否存在layout，方法是`_include_layout?`：

```ruby
def _include_layout?(options)
  (options.keys & [:text, :inline, :partial]).empty? || options.key?(:layout)
end
```
如果没有指定`:text`，`:inline`，`:partial`这三个选项，或是指定了`:layout`，都被认为是有layout的。

对于有layout的情况，将会将`:layout`选项传入`_layout_for_option`，然后将返回值赋值给`:layout`选项。`_layout_for_option`的实现如下：

```ruby
# Determine the layout for a given name, taking into account the name type.
#
# ==== Parameters
# * <tt>name</tt> - The name of the template
def _layout_for_option(name)
  case name
  when String     then _normalize_layout(name)
  when Proc       then name
  when true       then Proc.new { _default_layout(true)  }
  when :default   then Proc.new { _default_layout(false) }
  when false, nil then nil
  else
    raise ArgumentError,
      "String, true, or false, expected for `layout'; you passed #{name.inspect}"
  end
end
```
可以看到如果传入字符串，则相当于执行了layout的名字。那么如果传入的名字还没有带`layout/`，则在之前添加`layout/`使之成为layout文件所在路径。其余情况均返回proc，其中`true`和`:default`将返回调用了`_default_layout`的proc，对于该方法的分析稍后进行。`_normalize_options`的最后一层是`AbstractController::Rendering`的实现：

```ruby
# Normalize options.
# :api: plugin
def _normalize_options(options)
  if options[:partial] == true
    options[:partial] = action_name
  end

  if (options.keys & [:partial, :file, :template]).empty?
    options[:prefixes] ||= _prefixes
  end

  options[:template] ||= (options[:action] || action_name).to_s
  options
end
```
其中`:partial`和`template`都设置成action的名字作为默认值，`:prefix`之前已经描述过，当前及祖先所有Controller的名字。

随后就进入了`render_to_body`方法，一样的多层体系，第一层是`ActionController::Compatibility`的实现：

```ruby
def render_to_body(options)
  options[:template].sub!(/^\//, '') if options.key?(:template)
  super || " "
end
```
仅仅只是除去`:template`选项的`/`符号，为了兼容性。然后是`ActionController::Renderers`的实现：

```ruby
def render_to_body(options)
  _handle_render_options(options) || super
end
```
`_handle_render_options`的实现是：

```ruby
def _handle_render_options(options)
  _renderers.each do |name|
    if options.key?(name)
      _process_options(options)
      return send("_render_option_#{name}", options.delete(name), options)
    end
  end
  nil
end
```
如果选项中存在之前声明过的Mime类型的话，这里就可以直接将对应的值返回回去。先执行`_process_options`方法，同样多层实现，`ActionController::Stream`是Rails中包含的可以用Streaming技术传输数据的模块，定义在`actionpack-3.2.13/lib/action_controller/metal/streaming.rb`中，实现如下：

```ruby
# Set proper cache control and transfer encoding when streaming
def _process_options(options) #:nodoc:
  super
  if options[:stream]
    if env["HTTP_VERSION"] == "HTTP/1.0"
      options.delete(:stream)
    else
      headers["Cache-Control"] ||= "no-cache"
      headers["Transfer-Encoding"] = "chunked"
      headers.delete("Content-Length")
    end
  end
end
```
这个方法在当`:stream`的选项为true的时候设置Streaming用的Header。随后是`ActionController::Rendering`：

```ruby
# Process controller specific options, as status, content-type and location.
def _process_options(options) #:nodoc:
  status, content_type, location = options.values_at(:status, :content_type, :location)

  self.status = status if status
  self.content_type = content_type if content_type
  self.headers["Location"] = url_for(location) if location

  super
end
```
主要是将选项中的`:status`，`:content_type`，`:location`参数赋值给Controller。

随后执行这句语句：`return send("_render_option_#{name}", options.delete(name), options)`

并不是所有Mime类型都有相对的方法，事实上Rails只定义了三种常见的类型，代码在`ActionController::Renderers::All`里：

```ruby
add :json do |json, options|
  json = json.to_json(options) unless json.kind_of?(String)
  json = "#{options[:callback]}(#{json})" unless options[:callback].blank?
  self.content_type ||= Mime::JSON
  json
end

add :js do |js, options|
  self.content_type ||= Mime::JS
  js.respond_to?(:to_js) ? js.to_js(options) : js
end

add :xml do |xml, options|
  self.content_type ||= Mime::XML
  xml.respond_to?(:to_xml) ? xml.to_xml(options) : xml
end
```
对于其他类型，就必须自己编写响应的回调方法了。

如果选项并没有指定响应的Mime类型的话，那就接着执行`render_to_body`的方法，接着是`AbstractController::Rendering`的实现：

```ruby
# Raw rendering of a template to a Rack-compatible body.
# :api: plugin
def render_to_body(options = {})
  _process_options(options)
  _render_template(options)
end
```
`_process_options`的功能已经详细描述，不再复述。至于`_render_template`也是多层实现，`ActionController::Streaming`的实现如下：

```ruby
# Call render_to_body if we are streaming instead of usual +render+.
def _render_template(options) #:nodoc:
  if options.delete(:stream)
    Rack::Chunked::Body.new view_renderer.render_body(view_context, options)
  else
    super
  end
end
```
对于指定了Stream的情况，则创建相应的`Rack::Chunked::Body`对象返回，这里不详细解析这种情况。`AbstractController::Rendering`中的实现是：

```ruby
# Find and renders a template based on the options given.
# :api: private
def _render_template(options) #:nodoc:
  lookup_context.rendered_format = nil if options[:formats]
  view_renderer.render(view_context, options)
end
```
这里的重点是第二句语句，首先是`view_renderer`：

```ruby
# Returns an object that is able to render templates.
def view_renderer
  @_view_renderer ||= ActionView::Renderer.new(lookup_context)
end
```
`ActionView::Renderer`封装传入的`lookup_context`去实现多种关于渲染的操作。

而`view_context`的实现是：

```ruby
# An instance of a view class. The default view class is ActionView::Base
#
# The view class must have the following methods:
# View.new[lookup_context, assigns, controller]
#   Create a new ActionView instance for a controller
# View#render[options]
#   Returns String with the rendered template
#
# Override this method in a module to change the default behavior.
def view_context
  view_context_class.new(view_renderer, view_assigns, self)
end
```
其中`view_context_class`的实现是：

```ruby
def view_context_class
  @_view_context_class ||= self.class.view_context_class
end
```
可以看到是一个类方法的代理，然后来看类方法：

```ruby
def view_context_class
  @view_context_class ||= begin
    routes  = _routes  if respond_to?(:_routes)
    helpers = _helpers if respond_to?(:_helpers)
    ActionView::Base.prepare(routes, helpers)
  end
end
```
这里的`_routes`事实上定义在`ActionDispatch::Routing::RouteSet`中：

```ruby
def url_helpers
  @url_helpers ||= begin
    routes = self

    helpers = Module.new do
      extend ActiveSupport::Concern
      include UrlFor

      @_routes = routes
      class << self
        delegate :url_for, :to => '@_routes'
      end
      extend routes.named_routes.module

      included do
        routes.install_helpers(self)
        singleton_class.send(:redefine_method, :_routes) { routes }
      end

      define_method(:_routes) { @_routes || routes }
    end

    helpers
  end
end
```
可以看到`_routes`其实是当前Rails的`RouteSet`对象。

至于`_helpers`则可以查看`AbstractController::Helpers`的代码，定义在`actionpack-3.2.13/lib/abstract_controller/helpers.rb`，其中有一段这样的代码：

```ruby
included do
  class_attribute :_helpers
  self._helpers = Module.new

  class_attribute :_helper_methods
  self._helper_methods = Array.new
end

module ClassMethods
  # When a class is inherited, wrap its helper module in a new module.
  # This ensures that the parent class's module can be changed
  # independently of the child class's.
  def inherited(klass)
    helpers = _helpers
    klass._helpers = Module.new { include helpers }
    klass.class_eval { default_helper_module! unless anonymous? }
    super
  end
end
```
关于Helper机制的具体解析将在下一个章节展开。

接着将`routes`和`helpers`传入到`ActionView::Base.prepare`方法中，`ActionView::Base`是所有View代码最终的执行环境，定义在`actionpack-3.2.13/lib/action_view/base.rb`中：

```ruby
# This method receives routes and helpers from the controller
# and return a subclass ready to be used as view context.
def prepare(routes, helpers) #:nodoc:
  Class.new(self) do
    if routes
      include routes.url_helpers
      include routes.mounted_helpers
    end

    if helpers
      include helpers
      self.helpers = helpers
    end
  end
end
```
可以看到这里创建了一个新的类，并在这个新类中包含进了`url_helpers`，`mounted_helpers`以及`helpers`三个模块。这三者构成了View执行时的方法集合。

随后来看`view_assigns`的实现：

```ruby
# This method should return a hash with assigns.
# You can overwrite this configuration per controller.
# :api: public
def view_assigns
  hash = {}
  variables  = instance_variable_names
  variables -= protected_instance_variables
  variables -= DEFAULT_PROTECTED_INSTANCE_VARIABLES
  variables.each { |name| hash[name.to_s[1, name.length]] = instance_variable_get(name) }
  hash
end
```
在这里`instance_variable_names`指的是`instance_variables`的字符串版本，而`protected_instance_variables`定义在`ActionController::Compatibility`中：

```ruby
self.protected_instance_variables = %w(
  @_status @_headers @_params @_env @_response @_request
  @_view_runtime @_stream @_url_options @_action_has_layout
)
```
`DEFAULT_PROTECTED_INSTANCE_VARIABLES`则还是定义在`AbstractController::DEFAULT_PROTECTED_INSTANCE_VARIABLES`中：

```ruby
DEFAULT_PROTECTED_INSTANCE_VARIABLES = %w(
  @_action_name @_response_body @_formats @_prefixes @_config
  @_view_context_class @_view_renderer @_lookup_context
)
```
随后返回值`hash`就是所有剩余`variables`中变量与它的值的Hash。

接着就创建了`ActionView::Base.prepare`返回的匿名类的实例：

```ruby
def initialize(context = nil, assigns = {}, controller = nil, formats = nil) #:nodoc:
  @_config = ActiveSupport::InheritableOptions.new

  # Handle all these for backwards compatibility.
  # TODO Provide a new API for AV::Base and deprecate this one.
  if context.is_a?(ActionView::Renderer)
    @view_renderer = context
  elsif
    lookup_context = context.is_a?(ActionView::LookupContext) ?
      context : ActionView::LookupContext.new(context)
    lookup_context.formats  = formats if formats
    lookup_context.prefixes = controller._prefixes if controller
    @view_renderer = ActionView::Renderer.new(lookup_context)
  end

  assign(assigns)
  assign_controller(controller)
  _prepare_context
end
```
这里主要是后面三步，首先是`assign`方法：

```ruby
def assign(new_assigns) # :nodoc:
  @_assigns = new_assigns.each { |key, value| instance_variable_set("@#{key}", value) }
end
```
这里事实上就是将前面获取到的变量的名值对赋进去。

然后是`assign_controller`的实现，这个实现定义在`ActionView::Helpers::ControllerHelper`，位置在`actionpack-3.2.13/lib/action_view/helpers/controller_helper.rb`中：

```ruby
def assign_controller(controller)
  if @_controller = controller
    @_request = controller.request if controller.respond_to?(:request)
    @_config  = controller.config.inheritable_copy if controller.respond_to?(:config)
  end
end
```
这里仅仅是简单的将`controller`，`request`和`config`赋值在View中。

随后是`_prepare_context`的实现，定义在`ActionView::Context`中，位置在`actionpack-3.2.13/lib/action_view/context.rb`中：

```ruby
def _prepare_context
  @view_flow     = OutputFlow.new
  @output_buffer = nil
  @virtual_path  = nil
end
```
这里的`OutputFlow`将在下文重点分析。

随后真正进入了`ActionView::Renderer`的`render`方法了：

```ruby
# Main render entry point shared by AV and AC.
def render(context, options)
  if options.key?(:partial)
    render_partial(context, options)
  else
    render_template(context, options)
  end
end
```
可以看到这里有两个分支，对于partial而言，`render_partial`是：

```ruby
# Direct access to partial rendering.
def render_partial(context, options, &block) #:nodoc:
  _partial_renderer.render(context, options, block)
end

def _partial_renderer #:nodoc:
  @_partial_renderer ||= PartialRenderer.new(@lookup_context)
end
```
可以看到实现类的`PartialRenderer`，而`render_template`的实现是：

```ruby
# Direct accessor to template rendering.
def render_template(context, options) #:nodoc:
  _template_renderer.render(context, options)
end

def _template_renderer #:nodoc:
  @_template_renderer ||= TemplateRenderer.new(@lookup_context)
end
```
可以看到实现类是`TemplateRenderer`。我们将在这里先解析`TemplateRenderer`，稍后则解析`PartialRenderer`。

`TemplateRenderer`的位置在`actionpack-3.2.13/lib/action_view/renderer/template_renderer.rb`，主要负责对Template的渲染工作，它的`render`方法的实现是：

```ruby
def render(context, options)
  @view    = context
  @details = extract_details(options)
  extract_format(options[:file] || options[:template], @details)
  template = determine_template(options)
  context  = @lookup_context

  unless context.rendered_format
    context.formats = template.formats unless template.formats.empty?
    context.rendered_format = context.formats.first
  end

  render_template(template, options[:layout], options[:locals])
end
```