# An Http Request Through Rails

### 08. Active Record

本章其实已经脱离《An Http Request Through Rails》的范畴，仅仅作为学习之需。由于Active Record并不是一个完整的运作流程，本章只能通过多个例子解析Active Record的几个方面。

####Find####

#####Find all#####

首先就以一段最基本的代码开始吧，数据库是SQLite3，这里用的ActiveRecord对象是User，没有任何特别的属性：

```ruby
User.all
```
首先`all`方法属于`ActiveRecord::Querying`的`delegate`，`ActiveRecord::Querying`定义在`activerecord-3.2.13/lib/active_record/querying.rb`，提供了多种ORM的query方法的`scoped`的`delegate`，目标都是`scoped`：

```ruby
delegate :find, :first, :first!, :last, :last!, :all, :exists?, :any?, :many?, :to => :scoped
delegate :first_or_create, :first_or_create!, :first_or_initialize, :to => :scoped
delegate :destroy, :destroy_all, :delete, :delete_all, :update, :update_all, :to => :scoped
delegate :find_each, :find_in_batches, :to => :scoped
delegate :select, :group, :order, :except, :reorder, :limit, :offset, :joins,
         :where, :preload, :eager_load, :includes, :from, :lock, :readonly,
         :having, :create_with, :uniq, :to => :scoped
delegate :count, :average, :minimum, :maximum, :sum, :calculate, :pluck, :to => :scoped
```
除此以外还提供了两个可以直接用SQL查询的方法，`find_by_sql`和`count_by_sql`。

接着就执行了`scoped`方法，`scoped`是`ActiveRecord::Scoping::Named`模块下的类方法，定义在`activerecord-3.2.13/lib/active_record/scoping/named.rb`：

```ruby
# Returns an anonymous \scope.
#
#   posts = Post.scoped
#   posts.size # Fires "select count(*) from  posts" and returns the count
#   posts.each {|p| puts p.name } # Fires "select * from posts" and loads post objects
#
#   fruits = Fruit.scoped
#   fruits = fruits.where(:color => 'red') if options[:red_only]
#   fruits = fruits.limit(10) if limited?
#
# Anonymous \scopes tend to be useful when procedurally generating complex
# queries, where passing intermediate values (\scopes) around as first-class
# objects is convenient.
#
# You can define a \scope that applies to all finders using
# ActiveRecord::Base.default_scope.
def scoped(options = nil)
  if options
    scoped.apply_finder_options(options)
  else
    if current_scope
      current_scope.clone
    else
      scope = relation
      scope.default_scoped = true
      scope
    end
  end
end
```
`scoped`方法允许传入多个查询选项来实现更多的查询，但我们这里并不传入任何参数。对于已经设置了scope的代码来说，调用scoped会把当前scope克隆后返回回去，不过我们这里并没有设置scope，因此将调用`relation`方法返回一个`ActiveRecord::Relation`对象，设置默认scope，然后返回。

`relation`方法定义在`ActiveRecord::Base`中，`activerecord-3.2.13/lib/active_record/base.rb`文件内，这个类众所周知是ActiveRecord的核心类。`relation`方法的实现如下：

```ruby
def relation #:nodoc:
  relation = Relation.new(self, arel_table)

  if finder_needs_type_condition?
    relation.where(type_condition).create_with(inheritance_column.to_sym => sti_name)
  else
    relation
  end
end
```
这里一开始就创建了`ActiveRecord::Relation`类的对象，该类定义在`activerecord-3.2.13/lib/active_record/relation.rb`中，这个类暂时存储了当前所有查询条件，是实现Lazy Query的核心，它的构造函数的实现是：

```ruby
ASSOCIATION_METHODS = [:includes, :eager_load, :preload]
MULTI_VALUE_METHODS = [:select, :group, :order, :joins, :where, :having, :bind]
SINGLE_VALUE_METHODS = [:limit, :offset, :lock, :readonly, :from, :reordering, :reverse_order, :uniq]

def initialize(klass, table)
  @klass, @table = klass, table

  @implicit_readonly = nil
  @loaded            = false
  @default_scoped    = false

  SINGLE_VALUE_METHODS.each {|v| instance_variable_set(:"@#{v}_value", nil)}
  (ASSOCIATION_METHODS + MULTI_VALUE_METHODS).each {|v| instance_variable_set(:"@#{v}_values", [])}
  @extensions = []
  @create_with_value = {}
end
```
可以看到这里针对所有可能的查询条件都初始化好了实例变量。

实例化`Relation`对象时调用到了`arel_table`方法，这个方法实现在`ActiveRecord::Base`中：

```ruby
def arel_table
  @arel_table ||= Arel::Table.new(table_name, arel_engine)
end
```
这里首先先确定了当前类对应的数据库的表名，方法是`table_name`，定义在`ActiveRecord::ModelSchema`模块中，`activerecord-3.2.13/lib/active_record/model_schema.rb`文件内，这个模块与Schema相关，针对例如与表，列，序列这样的数据库操作，`table_name`的实现方法是：

```ruby
def table_name
  reset_table_name unless defined?(@table_name)
  @table_name
end
```
对于还没有设定`@table_name`变量的情况，首先要调用`reset_table_name`去计算出一个表名，实现是：

```ruby
# Computes the table name, (re)sets it internally, and returns it.
def reset_table_name #:nodoc:
  if abstract_class?
    self.table_name = if superclass == Base || superclass.abstract_class?
                        nil
                      else
                        superclass.table_name
                      end
  elsif superclass.abstract_class?
    self.table_name = superclass.table_name || compute_table_name
  else
    self.table_name = compute_table_name
  end
end
```
可以看到，如果自身是`abstract_class`或是父类是`abstract_class`的话，则根据单表继承的规定继承了父类的表名，否则，调用`compute_table_name`方法计算出一个表名：

```ruby
# Computes and returns a table name according to default conventions.
def compute_table_name
  base = base_class
  if self == base
    # Nested classes are prefixed with singular parent table name.
    if parent < ActiveRecord::Base && !parent.abstract_class?
      contained = parent.table_name
      contained = contained.singularize if parent.pluralize_table_names
      contained += '_'
    end
    "#{full_table_name_prefix}#{contained}#{undecorated_table_name(name)}#{table_name_suffix}"
  else
    # STI subclasses always use their superclass' table.
    base.table_name
  end
end
```
首先要找出一个被用于计算表名的类对象，这里调用`base_class`的实现：

```ruby
# Returns the base AR subclass that this class descends from. If A
# extends AR::Base, A.base_class will return A. If B descends from A
# through some arbitrarily deep hierarchy, B.base_class will return A.
#
# If B < A and C < B and if A is an abstract_class then both B.base_class
# and C.base_class would return B as the answer since A is an abstract_class.
def base_class
  class_of_active_record_descendant(self)
end

# Returns the class descending directly from ActiveRecord::Base or an
# abstract class, if any, in the inheritance hierarchy.
def class_of_active_record_descendant(klass)
  if klass == Base || klass.superclass == Base || klass.superclass.abstract_class?
    klass
  elsif klass.superclass.nil?
    raise ActiveRecordError, "#{name} doesn't belong in a hierarchy descending from ActiveRecord"
  else
    class_of_active_record_descendant(klass.superclass)
  end
end
```
这里的规则基本上按照`base_class`的注释所描述的那样，不再翻译。

随后，注意`parent`方法，这个方法来自于`activesupport-3.2.13/lib/active_support/core_ext/module/introspection.rb`的core hack，当该类是某个类或是模块的内部类的时候，返回其外部模块或类。

当该类`parent`也是ActiveRecord类，并且不是抽象类的话，这里将`parent`类的表名取出，如果发现是复数的话，转换成单数作为前缀加在表名的前面。

`full_table_name_prefix`搜查所有`parents`的`table_name_prefix`属性，如果都没有则使用当前类的`table_name_prefix`属性：

```ruby
def full_table_name_prefix #:nodoc:
  (parents.detect{ |p| p.respond_to?(:table_name_prefix) } || self).table_name_prefix
end
```

计算表名的核心方法是`undecorated_table_name`：

```ruby
# Guesses the table name, but does not decorate it with prefix and suffix information.
def undecorated_table_name(class_name = base_class.name)
  table_name = class_name.to_s.demodulize.underscore
  table_name = table_name.pluralize if pluralize_table_names
  table_name
end
```
这个方法非常简单，无需详细解释。另外如果是单表继承的话总是搜索父类的表名。好了，表名的解释到此为止，接着是初始化`Arel::Table`需要的第二个参数`arel_engine`：

```ruby
def arel_engine
  @arel_engine ||= begin
    if self == ActiveRecord::Base
      ActiveRecord::Base
    else
      connection_handler.retrieve_connection_pool(self) ? self : superclass.arel_engine
    end
  end
end
```
这里第一次提到了connection，因此有必要提及Active Record的数据库初始化，代码在`activerecord-3.2.13/lib/active_record/railtie.rb`中，`ActiveRecord::Railtie`内：

```ruby
# This sets the database configuration from Configuration#database_configuration
# and then establishes the connection.
initializer "active_record.initialize_database" do |app|
  ActiveSupport.on_load(:active_record) do
    db_connection_type = "DATABASE_URL"
    unless ENV['DATABASE_URL']
      db_connection_type  = "database.yml"
      self.configurations = app.config.database_configuration
    end
    Rails.logger.info "Connecting to database specified by #{db_connection_type}"

    establish_connection
  end
end
```
这段代码主要是`establish_connection`方法，它初始化了数据库相关部分：

```ruby
def self.establish_connection(spec = ENV["DATABASE_URL"])
  resolver = ConnectionSpecification::Resolver.new spec, configurations
  spec = resolver.spec

  unless respond_to?(spec.adapter_method)
    raise AdapterNotFound, "database configuration specifies nonexistent #{spec.config[:adapter]} adapter"
  end

  remove_connection
  connection_handler.establish_connection name, spec
end
```
`ConnectionSpecification::Resolver`定义在`activerecord-3.2.13/lib/active_record/connection_adapters/abstract/connection_specification.rb`中，其功能是创建所需的`ConnectionSpecification`对象，调用`spec`方法即可进行解析：

```ruby
def spec
  case config
  when nil
    raise AdapterNotSpecified unless defined?(Rails.env)
    resolve_string_connection Rails.env
  when Symbol, String
    resolve_string_connection config.to_s
  when Hash
    resolve_hash_connection config
  end
end
```
对于`config`，实质就是Rails环境，如果没有指定，则指定成`Rails.env`。然后执行`resolve_string_connection`方法：

```ruby
def resolve_string_connection(spec) # :nodoc:
  hash = configurations.fetch(spec) do |k|
    connection_url_to_hash(k)
  end

  raise(AdapterNotSpecified, "#{spec} database is not configured") unless hash

  resolve_hash_connection hash
end
```
这里通过前面指定的Rails环境获取到`database.yml`设置的数据库信息，如果不能获取到，则spec可能是一个URL，将调用`connection_url_to_hash`解析这个URL：

```ruby
def connection_url_to_hash(url) # :nodoc:
  config = URI.parse url
  adapter = config.scheme
  adapter = "postgresql" if adapter == "postgres"
  spec = { :adapter  => adapter,
           :username => config.user,
           :password => config.password,
           :port     => config.port,
           :database => config.path.sub(%r{^/},""),
           :host     => config.host }
  spec.reject!{ |_,value| value.blank? }
  spec.map { |key,value| spec[key] = URI.unescape(value) if value.is_a?(String) }
  if config.query
    options = Hash[config.query.split("&").map{ |pair| pair.split("=") }].symbolize_keys
    spec.merge!(options)
  end
  spec
end
```
随后调用`resolve_hash_connection`方法：

```ruby
def resolve_hash_connection(spec) # :nodoc:
  spec = spec.symbolize_keys

  raise(AdapterNotSpecified, "database configuration does not specify adapter") unless spec.key?(:adapter)

  begin
    require "active_record/connection_adapters/#{spec[:adapter]}_adapter"
  rescue LoadError => e
    raise LoadError, "Please install the #{spec[:adapter]} adapter: `gem install activerecord-#{spec[:adapter]}-adapter` (#{e.message})", e.backtrace
  end

  adapter_method = "#{spec[:adapter]}_connection"

  ConnectionSpecification.new(spec, adapter_method)
end
```
这里将根据设定的adapter信息加载数据库Adapter类，然后创建了相应的`ConnectionSpecification`对象。

随后，回到之前的`establish_connection`方法，必须判断`ActiveRecord::Base`是否加载了相应的适配器方法`"#{adapther_name"}_connection`，否则抛出异常。为了防止重复连接这里又调用了`remove_connection`，不过因为这里还没有作过任何连接所以其实不会做什么事情。最后调用了`connection_handler.establish_connection`方法建立连接：

```ruby
def establish_connection(name, spec)
  @connection_pools[spec] ||= ConnectionAdapters::ConnectionPool.new(spec)
  @class_to_pool[name] = @connection_pools[spec]
end
```
从代码中可以看到，`connection_handler`的`@connection_pool`是一个以`ConnectionSpecification`对象为Key，`ConnectionAdapters::ConnectionPool`对象为Value的Hash，而`@class_to_pool`则是以类名为Key，`ConnectionAdapters::ConnectionPool`为Value的Hash。

这里的方法虽然并没有真正的建立一个连向数据库的connection，但是已经做好了准备，当第一次执行`ActiveRecord::Base.connection`方法的时候就会真正的建立连接：

```ruby
# Returns the connection currently associated with the class. This can
# also be used to "borrow" the connection to do database work unrelated
# to any of the specific Active Records.
def connection
  retrieve_connection
end

def retrieve_connection
  connection_handler.retrieve_connection(self)
end
```
`connection_handler.retrieve_connection`的实现是：

```ruby
# Locate the connection of the nearest super class. This can be an
# active or defined connection: if it is the latter, it will be
# opened and set as the active connection for the class it was defined
# for (not necessarily the current class).
def retrieve_connection(klass) #:nodoc:
  pool = retrieve_connection_pool(klass)
  (pool && pool.connection) or raise ConnectionNotEstablished
end

def retrieve_connection_pool(klass)
  pool = @class_to_pool[klass.name]
  return pool if pool
  return nil if ActiveRecord::Base == klass
  retrieve_connection_pool klass.superclass
end
```
这里相当于之前初始化操作的逆操作，将取出对应的`ConnectionAdapters::ConnectionPool`对象，然后执行`connection`方法：

```ruby
# Retrieve the connection associated with the current thread, or call
# #checkout to obtain one if necessary.
#
# #connection can be called any number of times; the connection is
# held in a hash keyed by the thread id.
def connection
  synchronize do
    @reserved_connections[current_connection_id] ||= checkout
  end
end
```
这里确定当前连接ID的方法是这样的：

```ruby
def current_connection_id #:nodoc:
  ActiveRecord::Base.connection_id ||= Thread.current.object_id
end
```
这里返回或是建立连接的方法是`checkout`：

```ruby
def checkout
  synchronize do
    waited_time = 0

    loop do
      conn = @connections.find { |c| c.lease }

      unless conn
        if @connections.size < @size
          conn = checkout_new_connection
          conn.lease
        end
      end

      if conn
        checkout_and_verify conn
        return conn
      end

      if waited_time >= @timeout
        raise ConnectionTimeoutError, "could not obtain a database connection#{" within #{@timeout} seconds" if @timeout} (waited #{waited_time} seconds). The max pool size is currently #{@size}; consider increasing it."
      end

      # Sometimes our wait can end because a connection is available,
      # but another thread can snatch it up first. If timeout hasn't
      # passed but no connection is avail, looks like that happened --
      # loop and wait again, for the time remaining on our timeout. 
      before_wait = Time.now
      @queue.wait( [@timeout - waited_time, 0].max )
      waited_time += (Time.now - before_wait)

      # Will go away in Rails 4, when we don't clean up
      # after leaked connections automatically anymore. Right now, clean
      # up after we've returned from a 'wait' if it looks like it's
      # needed, then loop and try again. 
      if(active_connections.size >= @connections.size)
        clear_stale_cached_connections!
      end
    end
  end
end
```
从代码中可见，一开始先从`@connecions`中找到一个`lease`返回有效值的连接，其中`lease`的实现定义在`ActiveRecord::ConnectionAdapters`中，`activerecord-3.2.13/lib/active_record/connection_adapters/abstract_adapter.rb`文件内，这个类是所有数据库Adapter的基类：

```ruby
def lease
  synchronize do
    unless in_use
      @in_use   = true
      @last_use = Time.now
    end
  end
end
```
可以看到只有当连接没有被使用的时候`lease`方才返回有效值。如果没有找到并且`@connections`里的连接没有超过上限（默认是5），则执行`checkout_new_connection`方法创建一个新的连接：

```ruby
def checkout_new_connection
  raise ConnectionNotEstablished unless @automatic_reconnect

  c = new_connection
  c.pool = self
  @connections << c
  c
end
```
其中`new_connection`方法会调用Adapter的代码：

```ruby
def new_connection
  ActiveRecord::Base.send(spec.adapter_method, spec.config)
end
```
创建好连接之后，对连接执行`lease`方法将其标记为已经使用。随后执行`checkout_and_verify`方法：

```ruby
def checkout_and_verify(c)
  c.run_callbacks :checkout do
    c.verify!
  end
  c
end
```
这个方法执行了`:checkout`这个Callback，传入了执行针对连接的`verify!`方法的block，其中`verify!`方法主要是验证连接是否有效，如果无效则重新连接：

```ruby
# Checks whether the connection to the database is still active (i.e. not stale).
# This is done under the hood by calling <tt>active?</tt>. If the connection
# is no longer active, then this method will reconnect to the database.
def verify!(*ignored)
  reconnect! unless active?
end
```
具体判断是否`active?`的方法以及重新连接的代码取决于Adapter的实现，这里不再深入。

这样一个checkout连接的过程就完成了，如果之前没有找到空闲的连接，但是`@connections`里的连接已满，此时就只能等待一段时间，然后试图清理掉已经执行结束的线程中的连接以换取更多可用的连接，然后循环再次重复上述checkout的过程，直到最终超时抛出错误为止。

这样，关于数据库连接的初始化和连接的过程已经叙述完毕，我们现在回到`relation`方法，这里的`finder_needs_type_condition?`通过判断column中是否有实现单表继承必要的Column，`'type'`，如果存在则认为这个类有单表继承：

```ruby
def descends_from_active_record?
  if superclass.abstract_class?
    superclass.descends_from_active_record?
  else
    superclass == Base || !columns_hash.include?(inheritance_column)
  end
end

# The name of the column containing the object's class when Single Table Inheritance is used
def inheritance_column
  if self == Base
    'type'
  else
    (@inheritance_column ||= nil) || superclass.inheritance_column
  end
end
```
最后设置`scope.default_scoped`为true，然后返回`Relation`对象，并且调用`all`方法，`all`方法定义在`ActiveRecord::FinderMethods`中，`activerecord-3.2.13/lib/active_record/relation/finder_methods.rb`内：

```ruby
# A convenience wrapper for <tt>find(:all, *args)</tt>. You can pass in all the
# same arguments to this method as you can to <tt>find(:all)</tt>.
def all(*args)
  args.any? ? apply_finder_options(args.first).to_a : to_a
end
```
暂时回避`apply_finder_options`不看，直接看`to_a`的实现：

```ruby
def to_a
  # We monitor here the entire execution rather than individual SELECTs
  # because from the point of view of the user fetching the records of a
  # relation is a single unit of work. You want to know if this call takes
  # too long, not if the individual queries take too long.
  #
  # It could be the case that none of the queries involved surpass the
  # threshold, and at the same time the sum of them all does. The user
  # should get a query plan logged in that case.
  logging_query_plan do
    exec_queries
  end
end
```
这里`logging_query_plan`与SQL Explain有关，我们之后再深入学习这个功能，先进入`exec_queries`：

```ruby
def exec_queries
  return @records if loaded?

  default_scoped = with_default_scope

  if default_scoped.equal?(self)
    @records = if @readonly_value.nil? && !@klass.locking_enabled?
      eager_loading? ? find_with_associations : @klass.find_by_sql(arel, @bind_values)
    else
      IdentityMap.without do
        eager_loading? ? find_with_associations : @klass.find_by_sql(arel, @bind_values)
      end
    end

    preload = @preload_values
    preload +=  @includes_values unless eager_loading?
    preload.each do |associations|
      ActiveRecord::Associations::Preloader.new(@records, associations).run
    end

    # @readonly_value is true only if set explicitly. @implicit_readonly is true if there
    # are JOINS and no explicit SELECT.
    readonly = @readonly_value.nil? ? @implicit_readonly : @readonly_value
    @records.each { |record| record.readonly! } if readonly
  else
    @records = default_scoped.to_a
  end

  @loaded = true
  @records
end
```
这里看下`with_default_scope`的实现：

```ruby
def with_default_scope #:nodoc:
  if default_scoped? && default_scope = klass.send(:build_default_scope)
    default_scope = default_scope.merge(self)
    default_scope.default_scoped = false
    default_scope
  else
    self
  end
end
```
这里的`default_scoped?`将返回true，但是本类的`build_default_scope`将返回nil，因为并不曾指定过`default_scope`，因此`with_default_scope`将返回self本身。这样继续看`exec_queries`的实现，这将使得`default_scoped`与self相等，因此进入`@readonly_value.nil? && !@klass.locking_enabled?`的判断（之所以做这个判断可能是回避`IdentityMap`类的bug，具体请见`activerecord-3.2.13/lib/active_record/identity_map.rb`的注释）。由于没有`@readonly_value`，所以前者返回true，同时column中没有`lock_version`这个特殊column，因此`locking_enabled?`返回false，所以将判断`eager_loading?`：

```ruby
def eager_loading?
  @should_eager_load ||=
    @eager_load_values.any? ||
    @includes_values.any? && (joined_includes_values.any? || references_eager_loaded_tables?)
end
```
由于里面提到的变量本次查询都没有设置，因此`eager_loading?`返回false。这样就会直接执行`@klass.find_by_sql(arel, @bind_values)`。

首先进入`arel`，`arel`是`ActiveRecord::QueryMethods`的方法，定义在`ruby-1.9.3-p429/gems/activerecord-3.2.13/lib/active_record/relation/query_methods.rb`中：

```ruby
def arel
  @arel ||= with_default_scope.build_arel
end
```
这里的`with_default_scope`已经解释过，这里的执行结果与之前一致，需要关心的是这里的`build_arel`：

```ruby
def build_arel
  arel = table.from table

  build_joins(arel, @joins_values) unless @joins_values.empty?

  collapse_wheres(arel, (@where_values - ['']).uniq)

  arel.having(*@having_values.uniq.reject{|h| h.blank?}) unless @having_values.empty?

  arel.take(connection.sanitize_limit(@limit_value)) if @limit_value
  arel.skip(@offset_value.to_i) if @offset_value

  arel.group(*@group_values.uniq.reject{|g| g.blank?}) unless @group_values.empty?

  order = @order_values
  order = reverse_sql_order(order) if @reverse_order_value
  arel.order(*order.uniq.reject{|o| o.blank?}) unless order.empty?

  build_select(arel, @select_values.uniq)

  arel.distinct(@uniq_value)
  arel.from(@from_value) if @from_value
  arel.lock(@lock_value) if @lock_value

  arel
end
```
事实上这里大部分代码并不执行，唯一执行的`build_select`也只是横向选择了表中所有列：

```ruby
def build_select(arel, selects)
  unless selects.empty?
    @implicit_readonly = false
    arel.project(*selects)
  else
    arel.project(@klass.arel_table[Arel.star])
  end
end
```
接着，将执行`find_by_sql`方法：

```ruby
def find_by_sql(sql, binds = [])
  logging_query_plan do
    connection.select_all(sanitize_sql(sql), "#{name} Load", binds).collect! { |record| instantiate(record) }
  end
end
```
首先关注`sanitize_sql`方法，这个方法定义在`ActiveRecord::Sanitization`模块内，`activerecord-3.2.13/lib/active_record/sanitization.rb`文件内，并且在这个模块内`sanitize_sql`方法是`sanitize_sql_for_conditions`方法的alias，因此我们看`sanitize_sql_for_conditions`：

```ruby
# Accepts an array, hash, or string of SQL conditions and sanitizes
# them into a valid SQL fragment for a WHERE clause.
#   ["name='%s' and group_id='%s'", "foo'bar", 4]  returns  "name='foo''bar' and group_id='4'"
#   { :name => "foo'bar", :group_id => 4 }  returns "name='foo''bar' and group_id='4'"
#   "name='foo''bar' and group_id='4'" returns "name='foo''bar' and group_id='4'"
def sanitize_sql_for_conditions(condition, table_name = self.table_name)
  return nil if condition.blank?

  case condition
  when Array; sanitize_sql_array(condition)
  when Hash;  sanitize_sql_hash_for_conditions(condition, table_name)
  else        condition
  end
end
```
不过`ActiveRecord::Sanitization`负责那些需要预处理的SQL语句，而那种情况下参数应该是数组或是哈希，而这里我们传入的是`Arel::SelectManager`对象，因此直接返回。

然后我们进入`connection.select_all`方法，这个方法分两层，外层是由`ActiveRecord::ConnectionAdapters::QueryCache`实现，定义在`activerecord-3.2.13/lib/active_record/connection_adapters/abstract/query_cache.rb`。它生成SQL并且将SQL执行结果缓存起来，而下一层由`ActiveRecord::ConnectionAdapters::DatabaseStatements`实现，定义在`activerecord-3.2.13/lib/active_record/connection_adapters/abstract/database_statements.rb`文件内。我们先关心`QueryCache`中的实现：

```ruby
def select_all(arel, name = nil, binds = [])
  if @query_cache_enabled && !locked?(arel)
    sql = to_sql(arel, binds)
    cache_sql(sql, binds) { super(sql, name, binds) }
  else
    super
  end
end
```
如果SQL Cache功能打开并且数据库没有被锁住的话（后者是因为数据库被锁住情况下执行相同SQL的结果与不锁住情况下的SQL结果可能有所不同），将先取得SQL语句，然后执行并将其结果cache。我们先看下`to_sql`的实现：

```ruby
# Converts an arel AST to SQL
def to_sql(arel, binds = [])
  if arel.respond_to?(:ast)
    visitor.accept(arel.ast) do
      quote(*binds.shift.reverse)
    end
  else
    arel
  end
end
```
这里对`visitor`执行`accept`方法并且传入之前得到的AST即可获取最终的SQL语句，然后执行`cache_sql`：

```ruby
def cache_sql(sql, binds)
  result =
    if @query_cache[sql].key?(binds)
      ActiveSupport::Notifications.instrument("sql.active_record",
        :sql => sql, :binds => binds, :name => "CACHE", :connection_id => object_id)
      @query_cache[sql][binds]
    else
      @query_cache[sql][binds] = yield
    end

  result.collect { |row| row.dup }
end
```
从代码中可以看到所有SQL执行的结果均缓存在`@query_cache`中，如果存在Cache则直接返回结果，否则执行block中的代码去执行`DatabaseStatements`中的同名方法：

```ruby
# Returns an array of record hashes with the column names as keys and
# column values as values.
def select_all(arel, name = nil, binds = [])
  select(to_sql(arel, binds), name, binds)
end
```
这里的`to_sql`传入的实际上是已经计算好的SQL，因此并不再次转换，而是由`select`执行SQL语句，这里的`select`方法定义在SQLite的Adapter类中：

```ruby
def select(sql, name = nil, binds = []) #:nodoc:
  exec_query(sql, name, binds).to_a
end

def exec_query(sql, name = nil, binds = [])
  log(sql, name, binds) do

    # Don't cache statements without bind values
    if binds.empty?
      stmt    = @connection.prepare(sql)
      cols    = stmt.columns
      records = stmt.to_a
      stmt.close
      stmt = records
    else
      cache = @statements[sql] ||= {
        :stmt => @connection.prepare(sql)
      }
      stmt = cache[:stmt]
      cols = cache[:cols] ||= stmt.columns
      stmt.reset!
      stmt.bind_params binds.map { |col, val|
        type_cast(val, col)
      }
    end

    ActiveRecord::Result.new(cols, stmt.to_a)
  end
end
```
这里的代码完全是针对SQLite库的调用，我们不再研究，这里仅仅需要关心取得需要查询的数据之后如何将其转换为ActiveRecord对象，这里先创建了`ActiveRecord::Result`对象，这是一个很简单的类，定义在`activerecord-3.2.13/lib/active_record/result.rb`中：

```ruby
def initialize(columns, rows)
  @columns   = columns
  @rows      = rows
  @hash_rows = nil
end
```
返回`ActiveRecord::Result`对象后，返回`select`方法，这里将执行`to_a`方法。由于`ActiveRecord::Result`include了`Enumerable`模块，`to_a`方法将调用`each`返回结果：

```ruby
def each
  hash_rows.each { |row| yield row }
end
```
这里核心方法是`hash_rows`，它将Column和结果集改成了哈希的形式：

```ruby
def hash_rows
  @hash_rows ||=
    begin
      # We freeze the strings to prevent them getting duped when
      # used as keys in ActiveRecord::Model's @attributes hash
      columns = @columns.map { |c| c.dup.freeze }
      @rows.map { |row|
        Hash[columns.zip(row)]
      }
    end
end
```
最后，将哈希转换成`ActiveRecord`对象的工作由`find_by_sql`调用的`instantiate`方法实现：

```ruby
# Finder methods must instantiate through this method to work with the
# single-table inheritance model that makes it possible to create
# objects of different types from the same table.
def instantiate(record)
  sti_class = find_sti_class(record[inheritance_column])
  record_id = sti_class.primary_key && record[sti_class.primary_key]

  if ActiveRecord::IdentityMap.enabled? && record_id
    instance = use_identity_map(sti_class, record_id, record)
  else
    instance = sti_class.allocate.init_with('attributes' => record)
  end

  instance
end
```
首先搜索需要初始化的类，因此将当前对象的`inheritance_column`(通常都是`'type'`)传入`find_sti_class`，该方法定义在`ActiveRecord::Inheritance`模块内，`activerecord-3.2.13/lib/active_record/inheritance.rb`中：

```ruby
def find_sti_class(type_name)
  if type_name.blank? || !columns_hash.include?(inheritance_column)
    self
  else
    begin
      if store_full_sti_class
        ActiveSupport::Dependencies.constantize(type_name)
      else
        compute_type(type_name)
      end
    rescue NameError
      raise SubclassNotFound,
        "The single-table inheritance mechanism failed to locate the subclass: '#{type_name}'. " +
        "This error is raised because the column '#{inheritance_column}' is reserved for storing the class in case of inheritance. " +
        "Please rename this column if you didn't intend it to be used for storing the inheritance class " +
        "or overwrite #{name}.inheritance_column to use another column for that information."
    end
  end
end
```
如果没有`inheritance_column`，则需要初始化的类就是自己本身，否则则初始化这个column的值代表的类。随后，如果启用了`ActiveRecord::IdentityMap`且初始化值中有主键部分，将搜索`IdentityMap`，如果有结果，则取出结果并对其重新初始化。如果没有结果或没有启用`ActiveRecord::IdentityMap`，则先创建其势力，然后调用`init_with`对其初始化：

```ruby
# Initialize an empty model object from +coder+. +coder+ must contain
# the attributes necessary for initializing an empty model object. For
# example:
#
#   class Post < ActiveRecord::Base
#   end
#
#   post = Post.allocate
#   post.init_with('attributes' => { 'title' => 'hello world' })
#   post.title # => 'hello world'
def init_with(coder)
  @attributes = self.class.initialize_attributes(coder['attributes'])
  @relation = nil

  @attributes_cache, @previously_changed, @changed_attributes = {}, {}, {}
  @association_cache = {}
  @aggregation_cache = {}
  @readonly = @destroyed = @marked_for_destruction = false
  @new_record = false
  run_callbacks :find
  run_callbacks :initialize

  self
end
```
这里调用了`initialize_attributes`方法完成对属性的初始化环节，这里分两层，一层由`ActiveRecord::AttributeMethods::Serialization`实现，负责线性化部分属性，实现在`activerecord-3.2.13/lib/active_record/attribute_methods/serialization.rb`中可以找到，另一层由`ActiveRecord::Locking::Optimistic`实现，负责控制Column版本，实现在`activerecord-3.2.13/lib/active_record/locking/optimistic.rb`文件中。

首先看`Serialization`的实现：

```ruby
def initialize_attributes(attributes, options = {}) #:nodoc:
  serialized = (options.delete(:serialized) { true }) ? :serialized : :unserialized
  super(attributes, options)

  serialized_attributes.each do |key, coder|
    if attributes.key?(key)
      attributes[key] = Attribute.new(coder, attributes[key], serialized)
    end
  end

  attributes
end
```
其中这个模块还包含一段这样的代码：

```ruby
included do
  # Returns a hash of all the attributes that have been specified for serialization as
  # keys and their class restriction as values.
  class_attribute :serialized_attributes
  self.serialized_attributes = {}
end
```
`serialized_attributes`是一个Hash，表示需要线性化的属性及初始化的方法，默认为空。如果传入的选项中没有指定`:serialized`为`false`或`nil`，则在初始化时将`serialized_attributes`创建成`ActiveRecord::AttributeMethods::Serialization::Attribute`对象，这样就可以调用`serialize`方法进行线性化了：

```ruby
class Attribute < Struct.new(:coder, :value, :state)
  def unserialized_value
    state == :serialized ? unserialize : value
  end

  def serialized_value
    state == :unserialized ? serialize : value
  end

  def unserialize
    self.state = :unserialized
    self.value = coder.load(value)
  end

  def serialize
    self.state = :serialized
    self.value = coder.dump(value)
  end
end
```
接着来看`Locking::Optimistic`的部分：

```ruby
# If the locking column has no default value set,
# start the lock version at zero. Note we can't use
# <tt>locking_enabled?</tt> at this point as
# <tt>@attributes</tt> may not have been initialized yet.
def initialize_attributes(attributes, options = {}) #:nodoc:
  if attributes.key?(locking_column) && lock_optimistically
    attributes[locking_column] ||= 0
  end

  attributes
end
```
这里只是将属性的`locking_column`(默认值是`'lock_version'`)初始化为0。

完成初始化后，返回`exec_queries`方法，将处理属性的`@preload_values`和`@readonly_values`部分，但这里这些值均为空，因此直接返回。

至此，一个简单的`User.all`执行完毕。

下面我们将尝试更加复杂的查询条件，更加复杂的Model关系，更加复杂的功能，来更深入的研究`ActiveRecord`。

#####Find by Id#####

然后，我们简单的加强了搜索条件，这次的代码是：

```ruby
User.find_by_id 1
```
`find`系列方法是Rails中最常用的搜索方法之一，虽然Rails 4之后`find_by_xxxx`系列退化为`find_by`方法，但是该方法依然有不错的学习价值。首先，毫无以外的进入了`method_missing`方法，该方法定义在`ActiveRecord::DynamicMatchers`中，位置在`activerecord-3.2.13/lib/active_record/dynamic_matchers.rb`里：

```ruby
# Enables dynamic finders like <tt>User.find_by_user_name(user_name)</tt> and
# <tt>User.scoped_by_user_name(user_name). Refer to Dynamic attribute-based finders
# section at the top of this file for more detailed information.
#
# It's even possible to use all the additional parameters to +find+. For example, the
# full interface for +find_all_by_amount+ is actually <tt>find_all_by_amount(amount, options)</tt>.
#
# Each dynamic finder using <tt>scoped_by_*</tt> is also defined in the class after it
# is first invoked, so that future attempts to use it do not run through method_missing.
def method_missing(method_id, *arguments, &block)
  if match = (DynamicFinderMatch.match(method_id) || DynamicScopeMatch.match(method_id))
    attribute_names = match.attribute_names
    super unless all_attributes_exists?(attribute_names)
    if !(match.is_a?(DynamicFinderMatch) && match.instantiator? && arguments.first.is_a?(Hash)) && arguments.size < attribute_names.size
      method_trace = "#{__FILE__}:#{__LINE__}:in `#{method_id}'"
      backtrace = [method_trace] + caller
      raise ArgumentError, "wrong number of arguments (#{arguments.size} for #{attribute_names.size})", backtrace
    end
    if match.respond_to?(:scope?) && match.scope?
      self.class_eval <<-METHOD, __FILE__, __LINE__ + 1
        def self.#{method_id}(*args)                                    # def self.scoped_by_user_name_and_password(*args)
          attributes = Hash[[:#{attribute_names.join(',:')}].zip(args)] #   attributes = Hash[[:user_name, :password].zip(args)]
                        gg                                                #
          scoped(:conditions => attributes)                             #   scoped(:conditions => attributes)
        end                                                             # end
      METHOD
      send(method_id, *arguments)
    elsif match.finder?
      options = if arguments.length > attribute_names.size
                  arguments.extract_options!
                else
                  {}
                end

      relation = options.any? ? scoped(options) : scoped
      relation.send :find_by_attributes, match, attribute_names, *arguments, &block
    elsif match.instantiator?
      scoped.send :find_or_instantiator_by_attributes, match, attribute_names, *arguments, &block
    end
  else
    super
  end
end
```
这里涉及到两个Matcher，一个是`DynamicFinderMatch`，另一个是`DynamicScopeMatch`，分别定义在`activerecord-3.2.13/lib/active_record/`目录下的`dynamic_finder_match.rb`和`dynamic_scope_match.rb`文件内，这里我们主要关注`DynamicFinderMatch`：

```ruby
module ActiveRecord

  # = Active Record Dynamic Finder Match
  #
  # Refer to ActiveRecord::Base documentation for Dynamic attribute-based finders for detailed info
  #
  class DynamicFinderMatch
    def self.match(method)
      finder       = :first
      bang         = false
      instantiator = nil

      case method.to_s
      when /^find_(all_|last_)?by_([_a-zA-Z]\w*)$/
        finder = :last if $1 == 'last_'
        finder = :all if $1 == 'all_'
        names = $2
      when /^find_by_([_a-zA-Z]\w*)\!$/
        bang = true
        names = $1
      when /^find_or_create_by_([_a-zA-Z]\w*)\!$/
        bang = true
        instantiator = :create
        names = $1
      when /^find_or_(initialize|create)_by_([_a-zA-Z]\w*)$/
        instantiator = $1 == 'initialize' ? :new : :create
        names = $2
      else
        return nil
      end

      new(finder, instantiator, bang, names.split('_and_'))
    end

    def initialize(finder, instantiator, bang, attribute_names)
      @finder          = finder
      @instantiator    = instantiator
      @bang            = bang
      @attribute_names = attribute_names
    end

    attr_reader :finder, :attribute_names, :instantiator

    def finder?
      @finder && !@instantiator
    end

    def instantiator?
      @finder == :first && @instantiator
    end

    def creator?
      @finder == :first && @instantiator == :create
    end

    def bang?
      @bang
    end

    def save_record?
      @instantiator == :create
    end

    def save_method
      bang? ? :save! : :save
    end
  end
end
```
这里`find_by_id`将匹配第一个`when`语句，其中`finder`为默认的`:first`，意为只搜索第一个结果，随后，这里返回了`DynamicFinderMatch`的实例。

随后将确定`find_by`中的属性是否确实存在，调用`all_attributes_exists?`判断：

```ruby
def all_attributes_exists?(attribute_names)
  (expand_attribute_names_for_aggregates(attribute_names) -
   column_methods_hash.keys).empty?
end

# Similar in purpose to +expand_hash_conditions_for_aggregates+.
def expand_attribute_names_for_aggregates(attribute_names)
  attribute_names.map { |attribute_name|
    unless (aggregation = reflect_on_aggregation(attribute_name.to_sym)).nil?
      aggregate_mapping(aggregation).map do |field_attr, _|
        field_attr.to_sym
      end
    else
      attribute_name.to_sym
    end
  }.flatten
end
```
该方法与类的关联和聚合有关，下文将详细解析。这里该方法仅仅返回传入的属性。

而`column_methods_hash`则尽可能的返回更多的可能方法：

```ruby
# Returns a hash of all the methods added to query each of the columns in the table with the name of the method as the key
# and true as the value. This makes it possible to do O(1) lookups in respond_to? to check if a given method for attribute
# is available.
def column_methods_hash #:nodoc:
  @dynamic_methods_hash ||= column_names.inject(Hash.new(false)) do |methods, attr|
    attr_name = attr.to_s
    methods[attr.to_sym]       = attr_name
    methods["#{attr}=".to_sym] = attr_name
    methods["#{attr}?".to_sym] = attr_name
    methods["#{attr}_before_type_cast".to_sym] = attr_name
    methods
  end
end
```
二者相减如果不为空则说明参数中含有不存在的属性，将返回错误。随即则是一个判断参数是否过多的检查。接下来主要是一个分支，对于`DynamicScopeMatch`的情况，则创建一个同名方法，并且对该方法进行调用。在这个同名方法中则主要是针对`scoped`方法的调用。而对于我们目前关心的`DynamicFinderMatch`，将先获取到选项，随后调用`scoped`方法处理选项以获取正确的scope，最后调用`Relation`对象的`find_by_attributes`方法即可：

```ruby
def find_by_attributes(match, attributes, *args)
  conditions = Hash[attributes.map {|a| [a, args[attributes.index(a)]]}]
  result = where(conditions).send(match.finder)

  if match.bang? && result.nil?
    raise RecordNotFound, "Couldn't find #{@klass.name} with #{conditions.to_a.collect {|p| p.join(' = ')}.join(', ')}"
  else
    yield(result) if block_given?
    result
  end
end
```
首先生成了属性的key value对，然后将其放入`where`方法内，随后对返回值再调用`match.finder`方法，`match.finder`在这里取值为`:first`，其他可能的取值还有`:last`和`:all`。下面是`where`方法的代码：

```ruby
def where(opts, *rest)
  return self if opts.blank?

  relation = clone
  relation.where_values += build_where(opts, rest)
  relation
end

def build_where(opts, other = [])
  case opts
  when String, Array
    [@klass.send(:sanitize_sql, other.empty? ? opts : ([opts] + other))]
  when Hash
    attributes = @klass.send(:expand_hash_conditions_for_aggregates, opts)
    PredicateBuilder.build_from_hash(table.engine, attributes, table)
  else
    [opts]
  end
end
```
这里的`ActiveRecord::PredicateBuilder`类定义在`activerecord-3.2.13/lib/active_record/relation/predicate_builder.rb`中，提供了关于这类断言式的代码封装：

```ruby
module ActiveRecord
  class PredicateBuilder # :nodoc:
    def self.build_from_hash(engine, attributes, default_table, allow_table_name = true)
      predicates = attributes.map do |column, value|
        table = default_table

        if allow_table_name && value.is_a?(Hash)
          table = Arel::Table.new(column, engine)

          if value.empty?
            '1 = 2'
          else
            build_from_hash(engine, value, table, false)
          end
        else
          column = column.to_s

          if allow_table_name && column.include?('.')
            table_name, column = column.split('.', 2)
            table = Arel::Table.new(table_name, engine)
          end

          attribute = table[column]

          case value
          when ActiveRecord::Relation
            value = value.select(value.klass.arel_table[value.klass.primary_key]) if value.select_values.empty?
            attribute.in(value.arel.ast)
          when Array, ActiveRecord::Associations::CollectionProxy
            values = value.to_a.map {|x| x.is_a?(ActiveRecord::Base) ? x.id : x}
            ranges, values = values.partition {|v| v.is_a?(Range) || v.is_a?(Arel::Relation)}

            array_predicates = ranges.map {|range| attribute.in(range)}

            if values.include?(nil)
              values = values.compact
              if values.empty?
                array_predicates << attribute.eq(nil)
              else
                array_predicates << attribute.in(values.compact).or(attribute.eq(nil))
              end
            else
              array_predicates << attribute.in(values)
            end

            array_predicates.inject {|composite, predicate| composite.or(predicate)}
          when Range, Arel::Relation
            attribute.in(value)
          when ActiveRecord::Base
            attribute.eq(value.id)
          when Class
            # FIXME: I think we need to deprecate this behavior
            attribute.eq(value.name)
          else
            attribute.eq(value)
          end
        end
      end

      predicates.flatten
    end
  end
end
```
虽然这里的代码看上去非常复杂，几乎所有与where子句相关的SQL语句的功能都在这里被封装。但是我们需要的仅仅是调用属性的`eq`方法，并传入属性对应的值。最后将获取一个数组，其元素是一个`Arel::Nodes::Equality`对象。

`first`方法的实现也非常简单：

```ruby
# A convenience wrapper for <tt>find(:first, *args)</tt>. You can pass in all the
# same arguments to this method as you can to <tt>find(:first)</tt>.
def first(*args)
  if args.any?
    if args.first.kind_of?(Integer) || (loaded? && !args.first.kind_of?(Hash))
      limit(*args).to_a
    else
      apply_finder_options(args.first).first
    end
  else
    find_first
  end
end

def find_first
  if loaded?
    @records.first
  else
    @first ||= limit(1).to_a[0]
  end
end
```
`first`可以接受一个数字返回最前的多条数据，否则执行`find_first`方法。这个方法实质就是调用`limit(1).to_a[0]`语句，其中`limit`方法的实现非常简单：

```ruby
def limit(value)
  relation = clone
  relation.limit_value = value
  relation
end
```
而`to_a`的实现之前已经解释过，这里不再重复。

#####Find by Parameters#####

我们已经了解了`find_by`系列方法的内部机制，下面将进入更加复杂的查询方法，带参数绑定的命名查询，查询代码如下：

```ruby
User.where 'id = :id and name = :name and age = :age and admin = :admin', :id => id,
                                                                          :name => name,
                                                                          :age => age,
                                                                          :admin => admin
```
首先进入`where`方法：

```ruby
def where(opts, *rest)
  return self if opts.blank?

  relation = clone
  relation.where_values += build_where(opts, rest)
  relation
end

def build_where(opts, other = [])
  case opts
  when String, Array
    [@klass.send(:sanitize_sql, other.empty? ? opts : ([opts] + other))]
  when Hash
    attributes = @klass.send(:expand_hash_conditions_for_aggregates, opts)
    PredicateBuilder.build_from_hash(table.engine, attributes, table)
  else
    [opts]
  end
end
```
这两个方法其实之前已经读过，但是现在我们将探索`build_where`的第一个分支，`sanitize_sql`方法：

```ruby
# Accepts an array, hash, or string of SQL conditions and sanitizes
# them into a valid SQL fragment for a WHERE clause.
#   ["name='%s' and group_id='%s'", "foo'bar", 4]  returns  "name='foo''bar' and group_id='4'"
#   { :name => "foo'bar", :group_id => 4 }  returns "name='foo''bar' and group_id='4'"
#   "name='foo''bar' and group_id='4'" returns "name='foo''bar' and group_id='4'"
def sanitize_sql_for_conditions(condition, table_name = self.table_name)
  return nil if condition.blank?

  case condition
  when Array; sanitize_sql_array(condition)
  when Hash;  sanitize_sql_hash_for_conditions(condition, table_name)
  else        condition
  end
end
alias_method :sanitize_sql, :sanitize_sql_for_conditions
```
虽然这个方法之前也已经接触过，但是之前并没有详细解析，这里我们将重点研究这个方法，由于带参数绑定的方法传入的`condition`参数都是数组，因此进入`sanitize_sql_array`方法：

```ruby
# Accepts an array of conditions. The array has each value
# sanitized and interpolated into the SQL statement.
#   ["name='%s' and group_id='%s'", "foo'bar", 4]  returns  "name='foo''bar' and group_id='4'"
def sanitize_sql_array(ary)
  statement, *values = ary
  if values.first.is_a?(Hash) && statement =~ /:\w+/
    replace_named_bind_variables(statement, values.first)
  elsif statement.include?('?')
    replace_bind_variables(statement, values)
  elsif statement.blank?
    statement
  else
    statement % values.collect { |value| connection.quote_string(value.to_s) }
  end
end
```
由于是命名参数，将匹配第一个条件，将调用`replace_named_bind_variables`方法：

```ruby
def replace_named_bind_variables(statement, bind_vars) #:nodoc:
  statement.gsub(/(:?):([a-zA-Z]\w*)/) do
    if $1 == ':' # skip postgresql casts
      $& # return the whole match
    elsif bind_vars.include?(match = $2.to_sym)
      quote_bound_value(bind_vars[match])
    else
      raise PreparedStatementInvalid, "missing value for :#{match} in #{statement}"
    end
  end
end
```
由于PostgreSQL存在连续两个冒号的语句，因此需要适当规避，随后将传入参数对应的值传入`quote_bound_value`方法：

```ruby
def quote_bound_value(value, c = connection) #:nodoc:
  if value.respond_to?(:map) && !value.acts_like?(:string)
    if value.respond_to?(:empty?) && value.empty?
      c.quote(nil)
    else
      value.map { |v| c.quote(v) }.join(',')
    end
  else
    c.quote(value)
  end
end
```
这里主要是将获取的值增加引号，调用的方法是`connection.quote`，由于SQLite在这方面基本遵守标准，因此将进入`ActiveRecord::ConnectionAdapters::Quoting`，该模块负责各种与引号相关的实用功能，定义在`activerecord-3.2.13/lib/active_record/connection_adapters/abstract/quoting.rb`中：

```ruby
# Quotes the column value to help prevent
# {SQL injection attacks}[http://en.wikipedia.org/wiki/SQL_injection].
def quote(value, column = nil)
  # records are quoted as their primary key
  return value.quoted_id if value.respond_to?(:quoted_id)

  case value
  when String, ActiveSupport::Multibyte::Chars
    value = value.to_s
    return "'#{quote_string(value)}'" unless column

    case column.type
    when :binary then "'#{quote_string(column.string_to_binary(value))}'"
    when :integer then value.to_i.to_s
    when :float then value.to_f.to_s
    else
      "'#{quote_string(value)}'"
    end

  when true, false
    if column && column.type == :integer
      value ? '1' : '0'
    else
      value ? quoted_true : quoted_false
    end
    # BigDecimals need to be put in a non-normalized form and quoted.
  when nil        then "NULL"
  when BigDecimal then value.to_s('F')
  when Numeric    then value.to_s
  when Date, Time then "'#{quoted_date(value)}'"
  when Symbol     then "'#{quote_string(value.to_s)}'"
  else
    "'#{quote_string(YAML.dump(value))}'"
  end
end
```
可以看到这里根据数据类型划分了多个增加引号的方法，虽然凡是涉及到字符串都用单引号引起，但是对于处理字符串内部的引号的手段却各不相同，这里就不再解析了。

接下来经过多次循环，之前SQL语句中的参数均会被实际值替代，这样，最终的SQL语句将会被加入到`Relation`对象中，并合并到解析后的SQL语句中去。

####Relations####

##### Has many #####

随后，让我们来关注Active Record关于Relation的部分，代码是：

```ruby
class User < ActiveRecord::Base
  has_many :blogs
end

user.blogs
```
这段代码简单地为User类定义了一个`has_many`关系，随后调用了这个关系进行查询。我们现在将从定义关系的代码开始解析：

```ruby
def has_many(name, options = {}, &extension)
  Builder::HasMany.build(self, name, options, &extension)
end
```
这点代码在`ActiveRecord::Associations`的`ClassMethods`中被定义，文件在`activerecord-3.2.13/lib/active_record/associations.rb`。代码中提到了`Builder::HasMany`类，从名字可知，这个类负责建立`has_many`关系，定义在`activerecord-3.2.13/lib/active_record/associations/builder/has_many.rb`。这个类的祖先是同一模块下定义的`CollectionAssociation`和`Association`类。这里调用的`build`方法定义在`CollectionAssociation`类中：

```ruby
def self.build(model, name, options, &extension)
  new(model, name, options, &extension).build
end
```
这里初始化了`Builder::HasMany`类的对象，随即调用了它的`build`方法，这里的`build`分多个层次，最核心的是`Association`的定义：

```ruby
def build
  validate_options
  reflection = model.create_reflection(self.class.macro, name, options, model)
  define_accessors
  reflection
end
```
`validate_options`验证所有传入的key是否valid，代码非常简单，无需解释。随后调用了`model`（这里指的是`User`类）的`create_reflection`方法，该方法定义在`ActiveRecord::Reflection`模块中，`activerecord-3.2.13/lib/active_record/reflection.rb`文件内，这个方法主要是创建各种`Reflection`对象：

```ruby
def create_reflection(macro, name, options, active_record)
  case macro
    when :has_many, :belongs_to, :has_one, :has_and_belongs_to_many
      klass = options[:through] ? ThroughReflection : AssociationReflection
      reflection = klass.new(macro, name, options, active_record)
    when :composed_of
      reflection = AggregateReflection.new(macro, name, options, active_record)
  end

  self.reflections = self.reflections.merge(name => reflection)
  reflection
end
```
可以注意到这里出现了三种`Reflection`类，分别是专门用于`:through`选项的`ThroughReflection`，比较通用的`AssociationReflection`和用于`:composed_of`选项的`AggregateReflection`。各自都继承于父类`MacroReflection`（由于定义不是很复杂，因此都和`Reflection`模块定义在同一个文件中）。这里我们将用到`AssociationReflection`，并且定义它的实例。随后将`Relation`的名字和`Reflection`的实例放入`self.reflection`哈希中，以便之后查询。

之后的`define_accessors`主要定义对这一`Relation`的`reader`和`writer`方法，其中包括读写其对象和只读写其id数组的方法。

然后是`CollectionAssociation`的`build`方法：

```ruby
def build
  wrap_block_extension
  reflection = super
  CALLBACKS.each { |callback_name| define_callback(callback_name) }
  reflection
end
```
`wrap_block_extension`只是将`:extend`对应的模块保存起来，当前方法主要负责定义Callback，这里包括四个基本Callback方法：`:before_add, :after_add, :before_remove, :after_remove`。


```ruby
def build
  reflection = super
  configure_dependency
  reflection
end
```

